import json\nimport traceback\nimport inspect\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor\nfrom typing import Callable, Union, Optional, Any, get_origin, get_args\nfrom pprint import pprint\nfrom pydantic import BaseModel, ValidationError\nfrom dataclasses import dataclass, field\nfrom llm_easy_tools.schema_generator import get_name, parameters_basemodel_from_function, LLMFunction\nfrom llm_easy_tools.types import ChatCompletion, ChatCompletionMessageToolCall, ChatCompletionMessage, Function\n\nclass NoMatchingTool(Exception):\n    def __init__(self, message: str):\n        super().__init__(message)\n        self.message = message\n\n@dataclass\nclass ToolResult:\n    tool_call_id: str\n    name: str\n    output: Optional[Any] = None\n    arguments: Optional[dict[str, Any]] = None\n    error: Optional[Exception] = None\n    stack_trace: Optional[str] = None\n    soft_errors: list[Exception] = field(default_factory=list)\n    prefix: Optional[BaseModel] = None\n    tool: Optional[Union[Callable, BaseModel]] = None\n\n    def to_message(self) -> dict[str, str]:\n        content = str(self.error) if self.error else str(self.output) if self.output else ''\n        return {\n            \