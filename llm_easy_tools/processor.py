import json\nimport traceback\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor\nfrom typing import Callable, Union, Optional, Any, get_origin, get_args\nfrom pydantic import BaseModel, ValidationError\nfrom dataclasses import dataclass, field\nfrom llm_easy_tools.schema_generator import get_name, parameters_basemodel_from_function, LLMFunction\nfrom llm_easy_tools.types import ChatCompletion, ChatCompletionMessageToolCall, ChatCompletionMessage, Function\nclass NoMatchingTool(Exception):\n    def __init__(self, message):\n        self.message = message\n        super().__init__(self.message)\n">@dataclass\nclass ToolResult:\n    tool_call_id: str\n    name: str\n    output: Optional[Any] = None\n    arguments: Optional[dict[str, Any]] = None\n    error: Optional[Exception] = None\n    stack_trace: Optional[str] = None\n    soft_errors: list[Exception] = field(default_factory=list)\n    prefix: Optional[BaseModel] = None\n    tool: Optional[Union[Callable, BaseModel]] = None\n\n    def to_message(self) -> dict[str, str]:\n        if self.error is not None:\n            content = f"{self.error}"\n        elif self.output is None:\n            content = ''\n        elif isinstance(self.output, BaseModel):\n            content = f"{self.name} created"\n        else:\n            content = str(self.output)\n        return {\