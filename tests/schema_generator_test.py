import pytest\nfrom typing import List, Optional, Union, Annotated\nfrom pydantic import BaseModel, Field\nfrom llm_easy_tools import get_function_schema, LLMFunction\nfrom llm_easy_tools.schema_generator import parameters_basemodel_from_function, get_name, get_tool_defs\n\ndef simple_function(count: int, size: Optional[float] = None) -> None:\n    \"\"\"Simple function that takes a count and an optional size.\n\n    Args:\n        count (int): The count value.\n        size (Optional[float], optional): The size value. Defaults to None.\n    \"\"\"\n    pass\n\ndef simple_function_no_docstring(apple: Annotated[str, 'The apple'], banana: Annotated[str, 'The banana']) -> None:\n    \"\"\"Function with annotated parameters.\n\n    Args:\n        apple (Annotated[str, 'The apple']): Description of apple.\n        banana (Annotated[str, 'The banana']): Description of banana.\n    \"\"\"\n    pass\n\ndef test_function_schema() -> None:\n    \"\"\"Test function schema generation.\n\n    This test checks if the function schema is generated correctly for a simple function.\n    \"\"\"\n    function_schema = get_function_schema(simple_function)\n    assert function_schema['name'] == 'simple_function'\n    assert function_schema['description'] == 'Simple function that takes a count and an optional size.'\n    params_schema = function_schema['parameters']\n    assert len(params_schema['properties']) == 2\n    assert params_schema['type'] == 'object'\n    assert params_schema['properties']['count']['type'] == 'integer'\n    assert 'size' in params_schema['properties']\n    assert 'title' not in params_schema\n    assert 'title' not in params_schema['properties']['count']\n    assert 'description' not in params_schema\n\ndef test_function_with_no_params() -> None:\n    \"\"\"Test function with no parameters.\n\n    This test checks if the function schema is generated correctly for a function with no parameters.\n    \"\"\"\n    def function_with_no_params() -> None:\n        \"\"\"Function with docstring but no parameters.\n\n        This function has a docstring and takes no parameters.\n        \"\"\"\n        pass\n\n    result = get_function_schema(function_with_no_params)\n    assert result['name'] == 'function_with_no_params'\n    assert result['description'] == 'This function has a docstring and takes no parameters.'\n    assert result['parameters']['properties'] == {}\n\ndef test_function_no_doc() -> None:\n    \"\"\"Test function without docstring.\n\n    This test checks if the function schema is generated correctly for a function without a docstring.\n    \"\"\"\n    def function_no_doc() -> None:\n        \"\"\"Function without docstring or parameters.\n\n        This function does nothing and has no parameters.\n        \"\"\"\n        pass\n\n    result = get_function_schema(function_no_doc)\n    assert result['name'] == 'function_no_doc'\n    assert result['description'] == ''\n    assert result['parameters']['properties'] == {}\n\ndef test_nested_schema() -> None:\n    \"\"\"Test nested schema generation.\n\n    This test checks if the schema is generated correctly for nested structures.\n    \"\"\"\n    class Foo(BaseModel):\n        count: int\n        size: Optional[float] = None\n\n    class Bar(BaseModel):\n        \"\"\"Some Bar\n\n        This is a bar class.\n        \"\"\"\n        apple: str = Field(description='The apple')\n        banana: str = Field(description='The banana')\n\n    class FooAndBar(BaseModel):\n        foo: Foo\n        bar: Bar\n\n    def nested_structure_function(foo: Foo, bars: List[Bar]) -> None:\n        \"\"\"Function with nested structures.\n\n        This function takes a Foo object and a list of Bar objects.\n        \"\"\"\n        pass\n\n    function_schema = get_function_schema(nested_structure_function)\n    assert function_schema['name'] == 'nested_structure_function'\n    assert function_schema['description'] == 'Function with nested structures'\n    assert len(function_schema['parameters']['properties']) == 2\n\n    function_schema = get_function_schema(FooAndBar)\n    assert function_schema['name'] == 'FooAndBar'\n    assert len(function_schema['parameters']['properties']) == 2\n\ndef test_method_schema() -> None:\n    \"\"\"Test method schema generation.\n\n    This test checks if the schema is generated correctly for methods in a class.\n    \"\"\"\n    class ExampleClass:\n        def simple_method(self, count: int, size: Optional[float] = None) -> None:\n            \"\"\"Simple method in a class.\n\n            This method takes a count and an optional size.\n\n            Args:\n                count (int): The count value.\n                size (Optional[float], optional): The size value. Defaults to None.\n            \"\"\"\n            pass\n\n    example_object = ExampleClass()\n\n    function_schema = get_function_schema(example_object.simple_method)\n    assert function_schema['name'] == 'simple_method'\n    assert function_schema['description'] == 'Simple method in a class'\n    params_schema = function_schema['parameters']\n    assert len(params_schema['properties']) == 2\n\ndef test_LLMFunction_initialization() -> None:\n    \"\"\"Test LLMFunction class initialization.\n\n    This test checks if the LLMFunction class is initialized correctly and if the schema is generated as expected.\n    \"\"\"\n    def new_simple_function(count: int, size: Optional[float] = None) -> None:\n        \"\"\"Simple function for LLMFunction test.\n\n        This function takes a count and an optional size.\n\n        Args:\n            count (int): The count value.\n            size (Optional[float], optional): The size value. Defaults to None.\n        \"\"\"\n        pass\n\n    func = LLMFunction(new_simple_function, name='changed_name')\n    function_schema = func.schema\n    assert function_schema['name'] == 'changed_name'\n    assert not 'strict' in function_schema or function_schema['strict'] == False\n\n    func = LLMFunction(simple_function, strict=True)\n    function_schema = func.schema\n    assert function_schema['strict'] == True\n\ndef test_schema_from_model_initialization() -> None:\n    \"\"\"Test schema generation from model initialization.\n\n    This test checks if the schema is generated correctly when initializing a model.\n    \"\"\"\n    class User(BaseModel):\n        \"\"\"A user object.\n\n        This class represents a user with a name and city.\n        \"\"\"\n        name: str\n        city: str\n\n    function_schema = get_function_schema(User)\n    assert function_schema['name'] == 'User'\n    assert function_schema['description'] == 'A user object'\n    assert len(function_schema['parameters']['properties']) == 2\n    assert len(function_schema['parameters']['required']) == 2\n\n    new_function = LLMFunction(User, name='extract_user_details')\n    assert new_function.schema['name'] == 'extract_user_details'\n    assert new_function.schema['description'] == 'A user object'\n    assert len(new_function.schema['parameters']['properties']) == 2\n    assert len(new_function.schema['parameters']['required']) == 2\n\ndef test_case_insensitive_schema_generation() -> None:\n    \"\"\"Test case insensitivity in schema generation.\n\n    This test checks if the schema generation is case insensitive when specified.\n    \"\"\"\n    class User(BaseModel):\n        \"\"\"A user object.\n\n        This class represents a user with a name and city.\n        \"\"\"\n        name: str\n        city: str\n\n    function_schema = get_function_schema(User, case_insensitive=True)\n    assert function_schema['name'] == 'user'\n    assert get_name(User, case_insensitive=True) == 'user'\n\ndef test_function_with_missing_type_annotation() -> None:\n    \"\"\"Test function with missing type annotation.\n\n    This test checks if a ValueError is raised when a function has a parameter without a type annotation.\n    \"\"\"\n    def function_with_missing_type(param) -> str:\n        return f'Value is {param}'\n\n    with pytest.raises(ValueError) as exc_info:\n        get_function_schema(function_with_missing_type)\n    assert str(exc_info.value) == 'Parameter \'param\' has no type annotation'\n\ndef test_pydantic_model_schema() -> None:\n    \"\"\"Test schema generation with Pydantic model.\n\n    This test checks if the schema is generated correctly when using a Pydantic model.\n    \"\"\"\n    class Query(BaseModel):\n        query: str\n        region: str\n\n    def search(query: Query) -> None:\n        \"\"\"Function using Pydantic model.\n\n        This function takes a Query object.\n\n        Args:\n            query (Query): The query object.\n        \"\"\"\n        pass\n\n    schema = get_tool_defs([search])\n\n    assert schema[0]['function']['name'] == 'search'\n    assert schema[0]['function']['description'] == ''\n    assert schema[0]['function']['parameters']['properties']['query']['$ref'] == '#/$defs/Query'\n\ndef test_strict_schema_generation() -> None:\n    \"\"\"Test strict schema generation.\n\n    This test checks if the schema is generated in strict mode correctly.\n    \"\"\"\n    class Address(BaseModel):\n        street: str\n        city: str\n\n    class Company(BaseModel):\n        name: str\n        speciality: str\n        addresses: List[Address]\n\n    def print_companies(companies: List[Company]) -> None:\n        \"\"\"Function with strict schema.\n\n        This function takes a list of Company objects.\n\n        Args:\n            companies (List[Company]): The list of company objects.\n        \"\"\"\n        pass\n\n    schema = get_tool_defs([print_companies], strict=True)\n\n    function_schema = schema[0]['function']\n\n    assert function_schema['name'] == 'print_companies'\n    assert function_schema['strict'] == True\n    assert function_schema['parameters']['additionalProperties'] == False\n    assert function_schema['parameters']['$defs']['Address']['additionalProperties'] == False\n    assert function_schema['parameters']['$defs']['Address']['properties']['street']['type'] == 'string'\n    assert function_schema['parameters']['$defs']['Company']['additionalProperties'] == False\n