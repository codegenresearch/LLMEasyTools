import pytest\nfrom unittest.mock import Mock\nfrom pydantic import BaseModel, Field, ValidationError\nfrom typing import Any, Optional, List\nfrom llm_easy_tools.types import SimpleMessage, SimpleToolCall, SimpleFunction, SimpleChoice, SimpleCompletion\nfrom llm_easy_tools.processor import process_response, process_tool_call, ToolResult, process_one_tool_call, _process_unpacked, _is_list_type, split_string_to_list, _extract_prefix_unpacked\nfrom llm_easy_tools import LLMFunction\nfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor\nimport json\nimport time\ndef mk_tool_call(name: str, args: dict) -> SimpleToolCall:\n    arguments = json.dumps(args)\n    return SimpleToolCall(id='A', function=SimpleFunction(name=name, arguments=arguments), type='function')\ndef mk_tool_call_jason(name: str, args: str) -> SimpleToolCall:\n    return SimpleToolCall(id='A', function=SimpleFunction(name=name, arguments=args), type='function')\ndef mk_chat_completion(tool_calls: List[SimpleToolCall]) -> SimpleCompletion:\n    return SimpleCompletion(\n        id='A',\n        created=0,\n        model='gpt-3.5-turbo',\n        object='chat.completion',\n        choices=[\n            SimpleChoice(\n                finish_reason='stop',\n                index=0,\n                message=SimpleMessage(role='assistant', tool_calls=tool_calls))\n        ]\n    )\ndef test_process_methods():\n    class TestTool:\n        def tool_method(self, arg: int) -> str:\n            return f'executed tool_method with param: {arg}'\n        def no_output(self, arg: int):\n            pass\n        def failing_method(self, arg: int) -> str:\n            raise Exception('Some exception')\n    tool = TestTool()\n    tool_call = mk_tool_call("tool_method", {"arg": 2})\n    result = process_tool_call(tool_call, [tool.tool_method])\n    assert isinstance(result, ToolResult)\n    assert result.output == 'executed tool_method with param: 2'\n    tool_call = mk_tool_call("failing_method", {"arg": 2})\n    result = process_tool_call(tool_call, [tool.failing_method])\n    assert isinstance(result, ToolResult)\n    assert "Some exception" in str(result.error)\n    message = result.to_message()\n    assert "Some exception" in message['content']\n    tool_call = mk_tool_call("no_output", {"arg": 2})\n    result = process_tool_call(tool_call, [tool.no_output])\n    assert isinstance(result, ToolResult)\n    message = result.to_message()\n    assert message['content'] == ''\ndef test_process_complex():\n    class Address(BaseModel):\n        street: str\n        city: str\n    class Company(BaseModel):\n        name: str\n        speciality: str\n        address: Address\n    def print_companies(companies: list[Company]) -> list[Company]:\n        return companies\n    company_list = [{\n        'address': {'city': 'Metropolis', 'street': '150 Futura Plaza'},\n        'name': 'Aether Innovations',\n        'speciality': 'sustainable energy solutions'\n    }]\n    tool_call = mk_tool_call("print_companies", {"companies": company_list})\n    result = process_tool_call(tool_call, [print_companies])\n    assert isinstance(result, ToolResult)\n    assert isinstance(result.output, list)\n    assert isinstance(result.output[0], Company)\ndef test_prefixing():\n    class Reflection(BaseModel):\n        relevancy: str\n    args = { 'relevancy': 'good', 'name': 'hammer'}\n    prefix = _extract_prefix_unpacked(args, Reflection)\n    assert isinstance(prefix, Reflection)\n    assert 'reflection' not in args # prefix params extracted\ndef test_json_fix():\n    class UserDetail(BaseModel):\n        name: str\n        age: int\n    original_user = UserDetail(name="John", age=21)\n    json_data = json.dumps(original_user.model_dump())\n    json_data = json_data[:-1]\n    json_data = json_data + ',}'\n    tool_call = mk_tool_call("UserDetail", json_data)\n    result = process_tool_call(tool_call, [UserDetail])\n    assert result.output == original_user\n    assert len(result.soft_errors) > 0\n    result = process_tool_call(tool_call, [UserDetail], fix_json_args=False)\n    assert isinstance(result.error, json.decoder.JSONDecodeError)\n    response = mk_chat_completion([tool_call])\n    results = process_response(response, [UserDetail])\n    assert results[0].output == original_user\n    assert len(results[0].soft_errors) > 0\n    results = process_response(response, [UserDetail], fix_json_args=False)\n    assert isinstance(results[0].error, json.decoder.JSONDecodeError)\ndef test_list_in_string_fix():\n    class User(BaseModel):\n        names: Optional[list[str]]\n    tool_call = mk_tool_call("User", {"names": "John, Doe"})\n    result = process_tool_call(tool_call, [User])\n    assert result.output.names == ["John", "Doe"]\n    assert len(result.soft_errors) > 0\n    tool_call = mk_tool_call("User", {"names": '["John", "Doe"]'})\n    result = process_tool_call(tool_call, [User])\n    assert result.output.names == ["John", "Doe"]\n    assert len(result.soft_errors) > 0\n    result = process_tool_call(tool_call, [User], fix_json_args=False)\n    assert isinstance(result.error, ValidationError)\ndef test_case_insensitivity():\n    class User(BaseModel):\n        name: str\n        city: str\n    response = mk_chat_completion([mk_tool_call("user", {"name": "John", "city": "Metropolis"})])\n    results = process_response(response, [User], case_insensitive=True)\n    assert results[0].output == User(name="John", city="Metropolis")\ndef test_parallel_tools():\n    class CounterClass:\n        def __init__(self):\n            self.counter = 0\n        def increment_counter(self):\n            self.counter += 1\n            time.sleep(1)\n    counter = CounterClass()\n    tool_call = mk_tool_call("increment_counter", {})\n    response = mk_chat_completion([tool_call] * 10)\n    executor = ThreadPoolExecutor()\n    start_time = time.time()\n    results = process_response(response, [counter.increment_counter], executor=executor)\n    end_time = time.time()\n    assert results[9].error is None\n    time_taken = end_time - start_time\n    assert counter.counter == 10\n    assert time_taken <= 3, f"Expected processing time to be less than or equal to 3 seconds, but was {time_taken}"\ndef test_process_one_tool_call():\n    class User(BaseModel):\n        name: str\n        age: int\n    response = mk_chat_completion([\n        mk_tool_call("User", {"name": "Alice", "age": 30}),\n        mk_tool_call("User", {"name": "Bob", "age": 25})\n    ])\n    result = process_one_tool_call(response, [User], index=0)\n    assert isinstance(result, ToolResult)\n    assert result.output == User(name="Alice", age=30)\n    result = process_one_tool_call(response, [User], index=1)\n    assert isinstance(result, ToolResult)\n    assert result.output == User(name="Bob", age=25)\n    result = process_one_tool_call(response, [User], index=2)\n    assert result is None\n    invalid_response = mk_chat_completion([mk_tool_call("InvalidFunction", {})])\n    result = process_one_tool_call(invalid_response, [User])\n    assert isinstance(result, ToolResult)\n    assert result.error is not None\n