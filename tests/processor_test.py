import pytest\nfrom unittest.mock import Mock\nfrom pydantic import BaseModel, Field, ValidationError\nfrom typing import Any, Optional, List\nfrom llm_easy_tools.types import SimpleMessage, SimpleToolCall, SimpleFunction, SimpleChoice, SimpleCompletion\nfrom llm_easy_tools.processor import process_response, process_tool_call, ToolResult, process_one_tool_call, _extract_prefix_unpacked\nfrom llm_easy_tools import LLMFunction\nfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor\nimport json\nimport time\n\ndef mk_tool_call(name, args):\n    arguments = json.dumps(args)\n    return SimpleToolCall(id='A', function=SimpleFunction(name=name, arguments=arguments), type='function')\n\ndef mk_tool_call_json(name, args):\n    return SimpleToolCall(id='A', function=SimpleFunction(name=name, arguments=args), type='function')\n\ndef mk_chat_completion(tool_calls):\n    return SimpleCompletion(\n        id='A',\n        created=0,\n        model='gpt-3.5-turbo',\n        object='chat.completion',\n        choices=[\n            SimpleChoice(\n                finish_reason='stop',\n                index=0,\n                message=SimpleMessage(role='assistant', tool_calls=tool_calls))\n        ]\n    )\n\ndef test_process_methods():\n    class TestTool:\n        def tool_method(self, arg: int) -> str:\n            return f'executed tool_method with param: {arg}'\n\n        def no_output(self, arg: int) -> None:\n            pass\n\n        def failing_method(self, arg: int) -> str:\n            raise Exception('Some exception')\n\n    tool = TestTool()\n\n    tool_call = mk_tool_call('tool_method', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.tool_method])\n    assert isinstance(result, ToolResult)\n    assert result.output == 'executed tool_method with param: 2'\n\n    tool_call = mk_tool_call('failing_method', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.failing_method])\n    assert isinstance(result, ToolResult)\n    assert 'Some exception' in str(result.error)\n    message = result.to_message()\n    assert 'Some exception' in message['content']\n\n    tool_call = mk_tool_call('no_output', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.no_output])\n    assert isinstance(result, ToolResult)\n    message = result.to_message()\n    assert message['content'] == ''\n\ndef test_process_complex():\n    class Address(BaseModel):\n        street: str\n        city: str\n\n    class Company(BaseModel):\n        name: str\n        speciality: str\n        address: Address\n\n    def print_companies(companies: list[Company]) -> list[Company]:\n        return companies\n\n    company_list = [{\n        'address': {'city': 'Metropolis', 'street': '150 Futura Plaza'},\n        'name': 'Aether Innovations',\n        'speciality': 'sustainable energy solutions'\n    }]\n\n    tool_call = mk_tool_call('print_companies', {'companies': company_list})\n    result = process_tool_call(tool_call, [print_companies])\n    assert isinstance(result, ToolResult)\n    assert isinstance(result.output, list)\n    assert isinstance(result.output[0], Company)\n\ndef test_prefixing():\n    class Reflection(BaseModel):\n        relevancy: str\n\n    args = {'relevancy': 'good', 'name': 'hammer'}\n    prefix = _extract_prefix_unpacked(args, Reflection)\n    assert isinstance(prefix, Reflection)\n    assert 'reflection' not in args  # prefix params extracted\n\ndef test_json_fix():\n    class UserDetail(BaseModel):\n        name: str\n        age: int\n\n    original_user = UserDetail(name='John', age=21)\n    json_data = json.dumps(original_user.model_dump())\n    json_data = json_data[:-1]\n    json_data = json_data + ',}'\n    tool_call = mk_tool_call('UserDetail', json_data)\n    result = process_tool_call(tool_call, [UserDetail])\n    assert result.output == original_user\n    assert len(result.soft_errors) > 0\n\n    result = process_tool_call(tool_call, [UserDetail], fix_json_args=False)\n    assert isinstance(result.error, json.decoder.JSONDecodeError)\n\n    response = mk_chat_completion([tool_call])\n    results = process_response(response, [UserDetail])\n    assert results[0].output == original_user\n    assert len(results[0].soft_errors) > 0\n\n    results = process_response(response, [UserDetail], fix_json_args=False)\n    assert isinstance(results[0].error, json.decoder.JSONDecodeError)\n\ndef test_list_in_string_fix():\n    class User(BaseModel):\n        names: Optional[list[str]]\n\n    tool_call = mk_tool_call('User', {'names': 'John, Doe'})\n    result = process_tool_call(tool_call, [User])\n    assert result.output.names == ['John', 'Doe']\n    assert len(result.soft_errors) > 0\n\n    tool_call = mk_tool_call('User', {'names': '[\