import pytest\nfrom unittest.mock import Mock\nfrom pydantic import BaseModel, Field, ValidationError\nfrom typing import Any, Optional\nfrom llm_easy_tools.types import SimpleMessage, SimpleToolCall, SimpleFunction, SimpleChoice, SimpleCompletion\nfrom llm_easy_tools.processor import process_response, process_tool_call, ToolResult, process_one_tool_call, _process_unpacked, _is_list_type, split_string_to_list, _extract_prefix_unpacked\nfrom llm_easy_tools import LLMFunction\nfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor, as_completed\nimport json\ndef mk_tool_call(name, args):\n    arguments = json.dumps(args)\n    return SimpleToolCall(id='A', function=SimpleFunction(name=name, arguments=arguments), type='function')\ndef mk_tool_call_json(name, args):\n    return SimpleToolCall(id='A', function=SimpleFunction(name=name, arguments=args), type='function')\ndef mk_chat_completion(tool_calls):\n    return SimpleCompletion(\n        id='A',\n        created=0,\n        model='gpt-3.5-turbo',\n        object='chat.completion',\n        choices=[\n            SimpleChoice(\n                finish_reason='stop',\n                index=0,\n                message=SimpleMessage(role='assistant', tool_calls=tool_calls))\n        ]\n    )\ndef test_process_methods():\n    class TestTool:\n        def tool_method(self, arg: int) -> str:\n            return f'executed tool_method with param: {arg}'\n        def no_output(self, arg: int):\n            pass\n        def failing_method(self, arg: int) -> str:\n            raise Exception('Some exception')\n    tool = TestTool()\n    tool_call = mk_tool_call("tool_method", {"arg": 2})\n    result = process_tool_call(tool_call, [tool.tool_method])\n    assert isinstance(result, ToolResult)\n    assert result.output == 'executed tool_method with param: 2'\n    tool_call = mk_tool_call("failing_method", {"arg": 2})\n    result = process_tool_call(tool_call, [tool.failing_method])\n    assert isinstance(result, ToolResult)\n    assert "Some exception" in str(result.error)\n    message = result.to_message()\n    assert "Some exception" in message['content']\n    tool_call = mk_tool_call("no_output", {"arg": 2})\n    result = process_tool_call(tool_call, [tool.no_output])\n    assert isinstance(result, ToolResult)\n    message = result.to_message()\n    assert message['content'] == ''\ndef test_process_complex():\n    class Address(BaseModel):\n        street: str\n        city: str\n    class Company(BaseModel):\n        name: str\n        speciality: str\n        address: Address\n    def print_companies(companies: list[Company]):\n        return companies\n    company_list = [{\n        'address': {'city': 'Metropolis', 'street': '150 Futura Plaza'},\n        'name': 'Aether Innovations',\n        'speciality': 'sustainable energy solutions'\n    }]\n    tool_call = mk_tool_call("print_companies", {"companies": company_list})\n    result = process_tool_call(tool_call, [print_companies])\n    assert isinstance(result, ToolResult)\n    assert isinstance(result.output, list)\n    assert isinstance(result.output[0], Company)\ndef test_prefixing():\n    class Reflection(BaseModel):\n        relevancy: str = Field(..., description="Whas the last retrieved information relevant and why?")\n    args = { 'relevancy': 'good', 'name': 'hammer'}\n    prefix = _extract_prefix_unpacked(args, Reflection)\n    assert isinstance(prefix, Reflection)\n    assert 'reflection' not in args # prefix params extracted\ndef test_json_fix():\n    class UserDetail(BaseModel):\n        name: str\n        age: int\n    original_user = UserDetail(name="John", age=21)\n    json_data = json.dumps(original_user.model_dump())\n    json_data = json_data[:-1]\n    json_data = json_data + ',}'\n    tool_call = mk_tool_call_json("UserDetail", json_data)\n    result = process_tool_call(tool_call, [UserDetail])\n    assert result.output == original_user\n    assert len(result.soft_errors) > 0\n    result = process_tool_call(tool_call, [UserDetail], fix_json_args=False)\n    assert isinstance(result.error, json.decoder.JSONDecodeError)\n    response = mk_chat_completion([tool_call])\n    results = process_response(response, [UserDetail])\n    assert results[0].output == original_user\n    assert len(results[0].soft_errors) > 0\n    results = process_response(response, [UserDetail], fix_json_args=False)\n    assert isinstance(results[0].error, json.decoder.JSONDecodeError)\ndef test_list_in_string_fix():\n    class User(BaseModel):\n        names: Optional[list[str]]\n    tool_call = mk_tool_call("User", {"names": "John, Doe"})\n    result = process_tool_call(tool_call, [User])\n    assert result.output.names == ["John", "Doe"]\n    assert len(result.soft_errors) > 0\n    tool_call = mk_tool_call("User", {"names": "[\"John\", \"Doe\"]"})\