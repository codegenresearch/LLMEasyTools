import pytest\nfrom llm_easy_tools.types import SimpleMessage, SimpleToolCall, SimpleFunction, SimpleChoice, SimpleCompletion, mk_chat_with_tool_call\nfrom llm_easy_tools.processor import process_response, process_tool_call, ToolResult, process_one_tool_call\nfrom llm_easy_tools import LLMFunction\nfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor\nfrom pydantic import BaseModel, Field, ValidationError\nimport json\nimport time\n\ndef create_tool_call(tool_name, args):\n    return SimpleToolCall(id='A', function=SimpleFunction(name=tool_name, arguments=json.dumps(args)), type='function')\n\ndef create_chat_completion(tool_calls):\n    return SimpleCompletion(\n        id='A',\n        created=0,\n        model='gpt-3.5-turbo',\n        object='chat.completion',\n        choices=[\n            SimpleChoice(\n                finish_reason='stop',\n                index=0,\n                message=SimpleMessage(role='assistant', tool_calls=tool_calls))\n        ]\n    )\n\ndef test_process_methods():\n    class TestTool:\n        def execute(self, arg: int) -> str:\n            return f'executed with param: {arg}'\n\n        def no_output(self, arg: int):\n            pass\n\n        def fail(self, arg: int) -> str:\n            raise Exception('Some exception')\n\n    tool = TestTool()\n\n    tool_call = create_tool_call('execute', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.execute])\n    assert isinstance(result, ToolResult)\n    assert result.output == 'executed with param: 2'\n\n    tool_call = create_tool_call('fail', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.fail])\n    assert isinstance(result, ToolResult)\n    assert 'Some exception' in str(result.error)\n    message = result.to_message()\n    assert 'Some exception' in message['content']\n\n    tool_call = create_tool_call('no_output', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.no_output])\n    assert isinstance(result, ToolResult)\n    message = result.to_message()\n    assert message['content'] == ''\n\ndef test_process_complex():\n    class Address(BaseModel):\n        street: str\n        city: str\n\n    class Company(BaseModel):\n        name: str\n        speciality: str\n        address: Address\n\n    def print_companies(companies: list[Company]):\n        return companies\n\n    company_list = [{\n        'address': {'city': 'Metropolis', 'street': '150 Futura Plaza'},\n        'name': 'Aether Innovations',\n        'speciality': 'sustainable energy solutions'\n    }]\n\n    tool_call = create_tool_call('print_companies', {'companies': company_list})\n    result = process_tool_call(tool_call, [print_companies])\n    assert isinstance(result, ToolResult)\n    assert isinstance(result.output, list)\n    assert isinstance(result.output[0], Company)\n\ndef test_json_fix():\n    class UserDetail(BaseModel):\n        name: str\n        age: int\n\n    original_user = UserDetail(name='John', age=21)\n    json_data = json.dumps(original_user.model_dump())[:-1] + ',}'\n\n    tool_call = create_tool_call('UserDetail', json_data)\n    result = process_tool_call(tool_call, [UserDetail])\n    assert result.output == original_user\n    assert len(result.soft_errors) > 0\n\n    result = process_tool_call(tool_call, [UserDetail], fix_json_args=False)\n    assert isinstance(result.error, json.decoder.JSONDecodeError)\n\n    response = create_chat_completion([tool_call])\n    results = process_response(response, [UserDetail])\n    assert results[0].output == original_user\n    assert len(results[0].soft_errors) > 0\n\n    results = process_response(response, [UserDetail], fix_json_args=False)\n    assert isinstance(results[0].error, json.decoder.JSONDecodeError)\n\ndef test_list_in_string_fix():\n    class User(BaseModel):\n        names: list[str] = Field(default_factory=list)\n\n    tool_call = create_tool_call('User', {'names': 'John, Doe'})\n    result = process_tool_call(tool_call, [User])\n    assert result.output.names == ['John', 'Doe']\n    assert len(result.soft_errors) > 0\n\n    tool_call = create_tool_call('User', {'names': '[\